<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ³¨éŸ³åˆ‡åˆ‡æ¨‚</title>
    <style>
        /* åŸºç¤æ¨£å¼é‡ç½®èˆ‡è¨­å®š */
        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: "PingFang TC", "Microsoft JhengHei", sans-serif;
            background: radial-gradient(circle at center, #ffffff 0%, #dcedc8 100%);
            /* èˆ’æœçš„æ·ºç¶ è‰² */
            color: #333;
        }

        /* ç•«é¢å±¤ç´š */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* é–‹å§‹èˆ‡çµæŸç•«é¢ */
        #start-screen,
        #game-over-screen {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 4rem;
            color: #0288d1;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        }

        h2 {
            font-size: 3rem;
            color: #d32f2f;
            margin-bottom: 1rem;
        }

        .difficulty-selector {
            margin-bottom: 2rem;
            font-size: 1.5rem;
            color: #0277bd;
            font-weight: bold;
        }

        select {
            font-size: 1.5rem;
            padding: 0.5rem 1rem;
            border-radius: 12px;
            border: 2px solid #03a9f4;
            outline: none;
            background: white;
            color: #0288d1;
            font-weight: bold;
        }

        .main-btn {
            font-size: 2.2rem;
            padding: 1rem 3rem;
            margin: 0.5rem;
            background: linear-gradient(135deg, #ff9800, #ff5722);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 87, 34, 0.4);
            transition: transform 0.1s, box-shadow 0.2s;
            font-weight: bold;
            touch-action: manipulation;
            /* ç¢ºä¿æŒ‰éˆ•èƒ½æ¥å—è§¸æ§é»æ“Š */
            z-index: 20;
        }

        .main-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(255, 87, 34, 0.4);
        }

        .challenge-btn {
            background: linear-gradient(135deg, #0288d1, #0277bd);
            box-shadow: 0 4px 15px rgba(2, 136, 209, 0.4);
        }

        /* éŠæˆ²æç¤º UI */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 5;
            color: #0277bd;
        }

        .hud-left {
            background: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 1.5rem;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .hearts {
            color: #f44336;
            letter-spacing: 5px;
            margin-top: 0.5rem;
        }

        .hud-right {
            display: none;
            /* ç§»é™¤è½æç¤ºé‡æ’­åŠŸèƒ½ */
        }

        /* éŠæˆ²å€åŸŸ & è»Œè·¡ç•«å¸ƒ */
        #game-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        #trail-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* æ³¨éŸ³ç‰©ä»¶ */
        .bopomofo {
            position: absolute;
            width: 0;
            height: 0;
            pointer-events: none;
            will-change: transform;
        }

        .bopomofo-inner {
            position: absolute;
            top: -55px;
            /* åŠå¾‘æ”¾å¤§å°é½Š */
            left: -55px;
            width: 110px;
            /* åŸæœ¬90px -> 110px */
            height: 110px;
            border-radius: 50%;
            background: #ffffff;
            border: 6px solid #fff;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), inset 0 -5px 0 rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            /* åŸæœ¬3.5rem -> 4rem */
            font-weight: 900;
            color: #424242;
        }

        /* æ¶ˆé™¤å‹•ç•« */
        .cut-success {
            animation: cutSuccess 0.4s ease-out forwards;
        }

        .cut-fail {
            animation: cutFail 0.4s ease-out forwards;
        }

        @keyframes cutSuccess {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                filter: brightness(1.2);
            }

            40% {
                transform: scale(1.4) rotate(15deg);
                opacity: 0.9;
            }

            100% {
                transform: scale(0) rotate(90deg);
                opacity: 0;
            }
        }

        @keyframes cutFail {
            0% {
                transform: scale(1);
                background: #f44336;
                color: white;
                border-color: #d32f2f;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(0) translateY(100px);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="screen">
        <h1>ğŸ—¡ï¸ æ³¨éŸ³åˆ‡åˆ‡æ¨‚ ğŸ‰</h1>
        <div class="difficulty-selector" style="text-align: center;">
            <div style="font-size: 1.2rem; color: #f44336; margin: 0.5rem 0 1.5rem 0;" id="high-score-display">
                æœ€é«˜åˆ†ç´€éŒ„(æŒ‘æˆ°æ¨¡å¼)ï¼š0
            </div>

            <label for="level-select">æ‹‹å‡ºé€Ÿåº¦ (é›£åº¦)ï¼š</label>
            <select id="level-select">
                <option value="1">åˆå­¸ (æ…¢é€Ÿ)</option>
                <option value="2" selected>æ™®é€š (é©ä¸­)</option>
                <option value="3">å¤§å¸« (æ¥µå¿«)</option>
            </select>
            <br><br>
            <label for="count-select">æ¯æ¬¡æ³¨éŸ³çƒæ•¸é‡ï¼š</label>
            <select id="count-select">
                <option value="2">2 é¡†</option>
                <option value="3">3 é¡†</option>
                <option value="4">4 é¡†</option>
                <option value="5" selected>5 é¡†</option>
                <option value="6">6 é¡†</option>
                <option value="7">7 é¡†</option>
                <option value="8">8 é¡†</option>
            </select>
        </div>

        <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
            <button id="start-practice-btn" class="main-btn">ğŸ¯ é–‹å§‹ç·´ç¿’æ¨¡å¼</button>
            <button id="start-challenge-btn" class="main-btn challenge-btn">â­• é–‹å§‹æŒ‘æˆ°æ¨¡å¼</button>
        </div>
    </div>

    <!-- éŠæˆ²ä¸­ç•«é¢ -->
    <div id="game-screen" class="screen hidden" style="background: transparent;">
        <div id="hud">
            <div class="hud-left">
                <div id="score-container">åˆ†æ•¸: <span id="score">0</span></div>
                <div id="hearts" class="hearts">â¤ï¸â¤ï¸â¤ï¸</div>
            </div>
        </div>
        <div id="game-area"></div>
        <canvas id="trail-canvas"></canvas>
    </div>

    <!-- çµæŸç•«é¢ -->
    <div id="game-over-screen" class="screen hidden">
        <h2 id="game-over-title">éŠæˆ²çµæŸ</h2>
        <div style="font-size: 2.5rem; margin-bottom: 3rem; color: #0288d1; font-weight: bold;">
            æœ€çµ‚å¾—åˆ†ï¼š<span id="final-score">0</span>
        </div>
        <button id="restart-btn" class="main-btn">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        const bopomofos = 'ã„…ã„†ã„‡ã„ˆã„‰ã„Šã„‹ã„Œã„ã„ã„ã„ã„‘ã„’ã„“ã„”ã„•ã„–ã„—ã„˜ã„™ã„§ã„¨ã„©ã„šã„›ã„œã„ã„ã„Ÿã„ ã„¡ã„¢ã„£ã„¤ã„¥ã„¦'.split('');

        // éŠæˆ²ç‹€æ…‹èˆ‡æœ€é«˜åˆ†
        let highScore = localStorage.getItem('bopomofo_highscore') || 0;
        let animationFrameId = null; // ç”¨ä¾†å„²å­˜å‹•ç•«å½±æ ¼çš„IDä»¥ä¾›çµæŸæ™‚å–æ¶ˆ
        let waveTimeoutId = null;    // ç”¨ä¾†è™•ç†æ³¢æ¬¡é–“æ ¼çš„è¨ˆæ™‚å™¨
        let state = {
            play: false, mode: 'practice', level: 3, itemCount: 5,
            score: 0, correctCount: 0, lives: 3,
            items: [], targetChar: '', lastTargetChar: '', waveActive: false,
            practicePool: [] // ç´€éŒ„ç·´ç¿’æ¨¡å¼é‚„æ²’è€ƒéçš„æ³¨éŸ³
        };

        // DOM å…ƒç´ 
        const dom = {
            startScreen: document.getElementById('start-screen'),
            gameScreen: document.getElementById('game-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            scoreContainer: document.getElementById('score-container'),
            score: document.getElementById('score'),
            hearts: document.getElementById('hearts'),
            highScoreDisplay: document.getElementById('high-score-display'),
            levelSelect: document.getElementById('level-select'),
            countSelect: document.getElementById('count-select'),
            gameArea: document.getElementById('game-area'),
            gameOverTitle: document.getElementById('game-over-title'),
            finalScore: document.getElementById('final-score'),
            trailCanvas: document.getElementById('trail-canvas')
        };
        const ctx = dom.trailCanvas.getContext('2d');
        let points = [];  // æ»‘å‹•è»Œè·¡é»
        let lastPoint = null;

        // éŸ³æ•ˆç³»çµ± (Web Audio API)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let speechUnlocked = false;

        function unlockSystemAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!speechUnlocked) {
                // è§¸ç™¼è¼‰å…¥è²éŸ³åº«
                window.speechSynthesis.getVoices();
                let u = new SpeechSynthesisUtterance('ã€€');
                u.volume = 0.01;
                window.speechSynthesis.speak(u);
                speechUnlocked = true;
            }
        }

        // åˆå§‹åŒ–éŠæˆ²èˆ‡äº‹ä»¶ç›£è½
        function init() {
            // ç”±æ–¼ iPad çš„ touch-action æˆ–äº‹ä»¶é é˜²å¯èƒ½åƒæ‰é»æ“Šï¼Œæˆ‘å€‘ç‚ºæŒ‰éˆ•åŒæ™‚ç¶å®š click èˆ‡ touchstart
            const bindClickAndTouch = (el, handler) => {
                let triggered = false;
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // é˜»æ­¢å¾ŒçºŒè§¸ç™¼ click
                    e.stopPropagation();
                    unlockSystemAudio(); // ç¢ºå¯¦è§£é–èªéŸ³èˆ‡éŸ³æ•ˆ
                    if (!triggered) { triggered = true; handler(e); setTimeout(() => triggered = false, 300); }
                }, { passive: false });
                el.addEventListener('click', (e) => {
                    unlockSystemAudio(); // ç¢ºå¯¦è§£é–èªéŸ³èˆ‡éŸ³æ•ˆ
                    if (!triggered) { triggered = true; handler(e); setTimeout(() => triggered = false, 300); }
                });
            };

            bindClickAndTouch(document.getElementById('start-practice-btn'), () => startGame('practice'));
            bindClickAndTouch(document.getElementById('start-challenge-btn'), () => startGame('challenge'));
            bindClickAndTouch(document.getElementById('restart-btn'), resetToStart);

            // æ»‘å‹•åˆ‡å‰²äº‹ä»¶ (iPad åŠ æ»‘é¼  é›™æ”¯æ´)
            dom.gameScreen.addEventListener('touchstart', handleSwipeStart, { passive: false });
            dom.gameScreen.addEventListener('touchmove', handleSwipeMove, { passive: false });
            dom.gameScreen.addEventListener('touchend', handleSwipeEnd);
            dom.gameScreen.addEventListener('mousedown', handleSwipeStart);
            dom.gameScreen.addEventListener('mousemove', handleSwipeMove);
            window.addEventListener('mouseup', handleSwipeEnd);

            // è¦–çª—ç¸®æ”¾è™•ç†
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        function resizeCanvas() {
            dom.trailCanvas.width = window.innerWidth;
            dom.trailCanvas.height = window.innerHeight;
        }

        // é–‹å§‹éŠæˆ²
        function startGame(mode) {
            // Safari éœ€è¦åœ¨ user gesture çš„ç•¶ä¸‹ç›´æ¥åˆå§‹åŒ– AudioContext
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // æ¯æ¬¡é‡æ–°é–‹å§‹å‰ï¼Œå¾¹åº•æ¸…é™¤èˆŠçš„è¿´åœˆèˆ‡å®šæ™‚å™¨
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (waveTimeoutId) {
                clearTimeout(waveTimeoutId);
                waveTimeoutId = null;
            }

            // æ ¹æ“šæ¨¡å¼é‡ç½®ç‹€æ…‹
            state.mode = mode;
            state.level = parseInt(dom.levelSelect.value);
            state.itemCount = parseInt(dom.countSelect.value);
            state.score = 0;
            state.correctCount = 0;
            state.lives = (state.mode === 'challenge') ? 3 : 999;
            state.play = true;
            state.items = [];
            state.lastTargetChar = '';
            points = [];

            // å¦‚æœæ˜¯ç·´ç¿’æ¨¡å¼ï¼Œæº–å‚™äº‚æ•¸é¡Œåº«æ± ç¢ºä¿10é¡Œä¸é‡è¤‡
            if (state.mode === 'practice') {
                state.practicePool = [...bopomofos];
                state.practicePool.sort(() => 0.5 - Math.random());
            }

            // æ ¹æ“šæ¨¡å¼é¡¯ç¤º/éš±è—åˆ†æ•¸
            if (state.mode === 'practice') {
                dom.scoreContainer.style.display = 'none';
            } else {
                dom.scoreContainer.style.display = 'block';
            }

            dom.startScreen.classList.add('hidden');
            dom.gameScreen.classList.remove('hidden');
            updateHUD();

            // çŸ­æš«ç­‰å¾…å¾Œé–‹å§‹ç¬¬ä¸€æ³¢
            waveTimeoutId = setTimeout(startWave, 800);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resetToStart() {
            dom.gameOverScreen.classList.add('hidden');
            dom.startScreen.classList.remove('hidden');
            updateHighScoreDisplay();
        }

        function gameOver(isWin = false) {
            state.play = false;
            state.waveActive = false; // ç¢ºä¿ä¸æœƒå†è§¸ç™¼ä¸‹ä¸€æ³¢

            // éŠæˆ²çµæŸæ™‚ç¢ºå¯¦åœæ­¢å‹•ç•«è¼ªè¿´èˆ‡ç™¼çƒè¨ˆæ™‚å™¨
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (waveTimeoutId) {
                clearTimeout(waveTimeoutId);
                waveTimeoutId = null;
            }

            dom.gameScreen.classList.add('hidden');
            dom.gameOverScreen.classList.remove('hidden');

            if (state.mode === 'practice' && isWin) {
                dom.gameOverTitle.innerText = "ğŸ¯ æ­å–œå®Œæˆç·´ç¿’ï¼";
                dom.gameOverTitle.style.color = "#4CAF50";
            } else {
                dom.gameOverTitle.innerText = "éŠæˆ²çµæŸ";
                dom.gameOverTitle.style.color = "#d32f2f";
            }

            // ç·´ç¿’æ¨¡å¼ä¸é¡¯ç¤ºæœ€çµ‚å¾—åˆ†
            if (state.mode === 'practice') {
                dom.finalScore.parentNode.style.display = 'none';
            } else {
                dom.finalScore.parentNode.style.display = 'block';
                dom.finalScore.innerText = state.score;
            }

            // æŒ‘æˆ°æ¨¡å¼å„²å­˜æœ€é«˜åˆ†
            if (state.mode === 'challenge' && state.score > highScore) {
                highScore = state.score;
                localStorage.setItem('bopomofo_highscore', highScore);
            }

            state.items.forEach(i => i.el.remove());
            state.items = [];

            // éŠæˆ²çµæŸæ™‚ç¢ºå¯¦åœæ­¢å‹•ç•«è¼ªè¿´èˆ‡ç™¼çƒè¨ˆæ™‚å™¨
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (waveTimeoutId) clearTimeout(waveTimeoutId);
        }

        function updateHighScoreDisplay() {
            dom.highScoreDisplay.innerText = `æœ€é«˜åˆ†ç´€éŒ„(æŒ‘æˆ°æ¨¡å¼)ï¼š${highScore}`;
        }

        function updateHUD() {
            dom.score.innerText = state.score;
            if (state.mode === 'challenge') {
                dom.hearts.innerText = 'â¤ï¸'.repeat(Math.max(0, state.lives));
            } else {
                dom.hearts.innerText = `é€²åº¦: ${state.correctCount} / 10`;
            }

            // éŠæˆ²çµæŸæ¢ä»¶åˆ¤å®š
            if (state.mode === 'challenge' && state.lives <= 0 && state.play) {
                gameOver(false);
            } else if (state.mode === 'practice' && state.correctCount >= 10 && state.play) {
                gameOver(true);
            }
        }

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'success') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
                osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.1); // A6
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'fail') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // èªéŸ³ç™¼è² (é€£ç™¼3æ¬¡)
        function speakTarget(char) {
            if (!char) return;

            // iPad / Safari BUGï¼šåœ¨ç³»çµ±ç„¡è²æˆ–è€…èªéŸ³éšŠåˆ—é‚„æ²’çµæŸæ™‚å‘¼å« cancel å¾ˆå®¹æ˜“é€ æˆæ•´å€‹å¼•æ“æ­»é–
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            // ç¨å¾®å»¶é²è®“ç³»çµ±é‡æ•´èªéŸ³ä½‡åˆ—å¾Œå†ç™¼é€æ–°éŸ³é »ï¼Œé¿å… iOS Safari åƒå­—æˆ–æ˜¯æ¶ˆéŸ³
            setTimeout(() => {
                let textToSpeak = `${char}ã€‚ ${char}ã€‚ ${char}`; // æ”¹ç”¨å¥è™Ÿå¼·è¿«ç”¢ç”Ÿé©ç•¶çš„é–“éš”
                let u = new SpeechSynthesisUtterance(textToSpeak);
                u.lang = 'zh-TW';
                u.rate = 1.0;
                u.volume = 1.0;
                window.speechSynthesis.speak(u);
            }, 50);
        }

        // ç”¢ç”Ÿä¸€æ³¢æ³¨éŸ³ç¬¦è™Ÿ
        function startWave() {
            if (!state.play) return;
            state.waveActive = true;

            // éš¨æ©Ÿé¸å®šç›®æ¨™ä¸¦ç™¼éŸ³
            if (state.mode === 'practice' && state.practicePool.length > 0) {
                // å¾ä¸é‡è¤‡é¡Œåº«ä¸­æŠ½å‡ºä¸€é¡Œ
                state.targetChar = state.practicePool.pop();
            } else {
                let availableCandidates = bopomofos;
                // æŒ‘æˆ°æ¨¡å¼: ç¢ºä¿è·Ÿä¸Šä¸€é¡Œä¸é‡è¤‡
                if (state.mode === 'challenge' && state.lastTargetChar) {
                    availableCandidates = bopomofos.filter(c => c !== state.lastTargetChar);
                }
                state.targetChar = availableCandidates[Math.floor(Math.random() * availableCandidates.length)];
                if (state.mode === 'challenge') state.lastTargetChar = state.targetChar;
            }
            speakTarget(state.targetChar);

            // æ±ºå®šæ•¸é‡èˆ‡é›£åº¦é‡åŠ› - é›£åº¦ 1 åˆ° 3
            let numItems = state.itemCount;
            let gravity = 0.05; // é è¨­åˆå­¸
            if (state.level === 2) gravity = 0.12;
            if (state.level === 3) gravity = 0.45; // å¤§å¸«æ¥µå¿«

            // æº–å‚™å¹²æ“¾é …
            let candidates = bopomofos.filter(c => c !== state.targetChar);
            candidates.sort(() => 0.5 - Math.random());

            let waveChars = [state.targetChar];
            for (let i = 0; i < numItems - 1; i++) waveChars.push(candidates[i]);
            waveChars.sort(() => 0.5 - Math.random()); // æ‰“äº‚é †åº

            let w = window.innerWidth;
            let h = window.innerHeight;
            let spacing = (w * 0.8) / (numItems || 1);

            waveChars.forEach((char, index) => {
                let el = document.createElement('div');
                el.className = 'bopomofo';
                let inner = document.createElement('div');
                inner.className = 'bopomofo-inner';
                inner.innerText = char;
                el.appendChild(inner);
                dom.gameArea.appendChild(el);

                // èµ·é»èˆ‡å‹•åŠ›åˆ†ä½ˆè¨ˆç®—
                let startX = w * 0.1 + (index * spacing) + (Math.random() * spacing * 0.5);
                let startY = h + 100 + Math.random() * 50;

                // é‡å°å¤§å¸«(3)ï¼Œå¢åŠ æ‹‹æŠ•é«˜åº¦èˆ‡æ©«å‘è®ŠåŒ–é€Ÿåº¦
                let destYVar = (state.level === 3) ? 0.6 : 0.4;
                let destY = h * (0.05 + Math.random() * destYVar);

                let vy = -Math.sqrt(2 * gravity * Math.abs(startY - destY));

                let horizontalSpeed = (state.level === 3) ? 0.015 : 0.005;
                let vx = (w / 2 - startX) * (0.003 + Math.random() * horizontalSpeed) + (Math.random() - 0.5) * (state.level === 3 ? 6 : 2);

                state.items.push({
                    el, inner, char,
                    isTarget: char === state.targetChar,
                    x: startX, y: startY,
                    vx, vy, gravity,
                    active: true,
                    rot: 0, // é–å®šæ—‹è½‰è§’ç‚º 0
                    vRot: 0 // æ²’æœ‰è§’é€Ÿåº¦
                });
            });
        }

        // æ ¸å¿ƒè¿´åœˆï¼šç‰©ç†é‹å‹•èˆ‡å…‰è»Œç¹ªè£½
        function gameLoop() {
            if (!state.play) return;

            let h = window.innerHeight;
            let targetActiveThisFrame = false;

            // 1. ç§»å‹•æ³¨éŸ³ç‰©ä»¶
            state.items.forEach(item => {
                if (!item.active) return;

                item.x += item.vx;
                item.y += item.vy;
                item.vy += item.gravity;
                item.rot += item.vRot;

                item.el.style.transform = `translate(${item.x}px, ${item.y}px) rotate(${item.rot}deg)`;

                // åˆ¤æ–·æ˜¯å¦æ‰è½å‡ºè¢å¹•åº•ç«¯è¢« Miss æ‰
                if (item.y > h + 150 && item.vy > 0) {
                    item.active = false;
                    item.el.remove();
                    if (item.isTarget) {
                        if (state.mode === 'challenge') state.lives--; // æ¼åˆ‡ç›®æ¨™æ‰£æ„›å¿ƒ
                        playSound('fail'); // æ’­æ”¾å¤±æ•—éŸ³æ•ˆ
                        updateHUD();
                    }
                } else {
                    if (item.isTarget) targetActiveThisFrame = true;
                }
            });

            // è™•ç†ç¢°æ’ (é˜²é‡ç–Š)
            for (let i = 0; i < state.items.length; i++) {
                for (let j = i + 1; j < state.items.length; j++) {
                    let a = state.items[i];
                    let b = state.items[j];
                    if (!a.active || !b.active) continue;
                    let dx = b.x - a.x;
                    let dy = b.y - a.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let minDist = 114; // åŠå¾‘ 55+55 åŠ ä¸Šç¨å¾®ç·©è¡ (å› ç‚ºçƒè®Šå¤§110pxäº†)
                    if (dist < minDist && dist > 0) {
                        let overlap = minDist - dist;
                        let nx = dx / dist;
                        let ny = dy / dist;

                        a.x -= nx * overlap * 0.5;
                        a.y -= ny * overlap * 0.5;
                        b.x += nx * overlap * 0.5;
                        b.y += ny * overlap * 0.5;

                        // å‹•é‡äº¤æ› (ç°¡å–®å½ˆæ€§ç¢°æ’)
                        let kx = (a.vx - b.vx) * 0.3;
                        let ky = (a.vy - b.vy) * 0.3;
                        a.vx -= kx; a.vy -= ky;
                        b.vx += kx; b.vy += ky;
                    }
                }
            }

            // æ¸…ç†å·²æ¨™è¨˜ç‚ºé active çš„ç‰©ä»¶
            state.items = state.items.filter(i => i.active);

            // å¦‚æœç•«é¢ä¸Šå·²ç¶“æ²’æœ‰ä»»ä½•æ³¨éŸ³çƒ (å…¨æ‰è½æˆ–è¢«æ¶ˆé™¤)ï¼Œåˆ¤å®šæœ¬æ³¢çµæŸ
            if (state.items.length === 0 && state.waveActive) {
                state.waveActive = false;

                // æŒ‘æˆ°æ¨¡å¼: æœ‰å‘½å°±ç¹¼çºŒ (ç„¡é™æŒ‘æˆ°)
                // ç·´ç¿’æ¨¡å¼: æœ‰å‘½ä¸”é”å°æ¬¡æ•¸æœªæ»¿ 10 æ¬¡æ‰ç¹¼çºŒ
                if (state.play) {
                    if (state.mode === 'challenge') {
                        if (state.lives > 0) {
                            if (waveTimeoutId) clearTimeout(waveTimeoutId);
                            waveTimeoutId = setTimeout(startWave, 1000);
                        }
                    } else if (state.mode === 'practice') {
                        if (state.lives > 0 && state.correctCount < 10) {
                            if (waveTimeoutId) clearTimeout(waveTimeoutId);
                            waveTimeoutId = setTimeout(startWave, 1000);
                        }
                    }
                }
            }

            // 2. ç¹ªè£½åˆ€å…‰è»Œè·¡
            ctx.clearRect(0, 0, dom.trailCanvas.width, dom.trailCanvas.height);
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.strokeStyle = `rgba(255, 255, 255, 0.9)`;
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00e5ff';
                ctx.stroke();
            }

            // è€åŒ–è»Œè·¡é»ä¸¦ç§»é™¤éèˆŠçš„é» (ç‡Ÿé€ æ·¡å‡ºæ•ˆæœ)
            points.forEach(p => p.age++);
            points = points.filter(p => p.age < 12);

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // åˆ‡å‰²ç¢°æ’åˆ¤å®šè¼”åŠ©å‡½å¼
        function getPointerPos(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }
        function sqr(x) { return x * x; }
        function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
        function distToSegmentSquared(p, v, w) {
            let l2 = dist2(v, w);
            if (l2 === 0) return dist2(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
        }

        // æ»‘å‹•/é»æ“Šæ¶ˆé™¤é‚è¼¯
        function checkCut(item, currentPoint, isTap) {
            if (!item.active) return;
            let cut = false;
            const r2 = 55 * 55; // ç¢°æ’åŠå¾‘æ”¾å¤§è‡³ 55
            if (isTap) {
                if (dist2(item, currentPoint) < r2) cut = true;
            } else {
                if (distToSegmentSquared(item, lastPoint, currentPoint) < r2) cut = true;
            }
            if (cut) {
                item.active = false;
                if (item.isTarget) {
                    item.inner.classList.add('cut-success');
                    state.score += 15;
                    state.correctCount++;
                    playSound('success'); // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
                } else {
                    item.inner.classList.add('cut-fail');
                    if (state.mode === 'challenge') state.lives--;
                    playSound('fail'); // æ’­æ”¾éŒ¯èª¤éŸ³æ•ˆ
                }
                updateHUD();
                setTimeout(() => { if (item.el && item.el.parentNode) item.el.remove(); }, 400);
            }
        }

        function handleSwipeStart(e) {
            if (!state.play) return;
            e.preventDefault();
            lastPoint = getPointerPos(e);
            points.push({ x: lastPoint.x, y: lastPoint.y, age: 0 });

            // æ”¯æ´å–®é»å³æ¶ˆé™¤
            state.items.forEach(item => checkCut(item, lastPoint, true));
        }

        function handleSwipeMove(e) {
            if (!state.play || !lastPoint) return;
            e.preventDefault();
            const currentPoint = getPointerPos(e);
            points.push({ x: currentPoint.x, y: currentPoint.y, age: 0 });

            state.items.forEach(item => checkCut(item, currentPoint, false));
            lastPoint = currentPoint;
        }

        function handleSwipeEnd(e) {
            lastPoint = null;
        }

        // å•Ÿå‹•å…¥å£
        window.onload = () => {
            init();
            updateHighScoreDisplay();
        };
    </script>
</body>

</html>